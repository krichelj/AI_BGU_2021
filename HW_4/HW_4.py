# -*- coding: utf-8 -*-
"""HW_4_AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W-WBd72fL70bOgoqwX-ySbZBkw8GMiun
"""

from typing import Dict
import matplotlib.pyplot as plt
from collections import OrderedDict
from treelib import Tree

from Graph import Graph

"""#HW4

##Config
"""

config = '''
#V5    ; number of vertices n in graph (from 1 to n)

#E1 1 2 W3       ; Edge from vertex 1 to vertex 2, weight 3
#E2 2 3 W2       ; Edge from vertex 2 to vertex 3, weight 2
#E3 3 4 W1 B0.1  ; Edge from vertex 3 to vertex 4, weight 3, probability of blockage 0.3
#E4 4 5 W1       ; Edge from vertex 4 to vertex 5, weight 1
#E5 2 4 W4       ; Edge from vertex 2 to vertex 4, weight 4
#Start 1
#Target 5
'''


def parse_config_string(config_string):
    vertices_config = {}
    edges_config = {}
    start = None
    target = None

    for line in config_string.split('\n'):
        if len(line) and line[0] == '#':
            identifier = line[1]

            if identifier == 'V':
                N = int(line[2:].split(' ')[0])
                for i in range(N):
                    vertices_config['V' + str(i + 1)] = 0
            elif identifier == 'E':
                splitted = line[1:].replace('W', '').split(' ')[0:5]
                e, v1_num, v2_num, w, b = splitted
                v1v2 = sorted([v1_num, v2_num])
                v1_id = 'V' + v1v2[0]
                v2_id = 'V' + v1v2[1]
                prob = 0 if not len(b) or b[0] != 'B' else float(b[1:])
                edges_config[v1_id + v2_id] = (v1_id, v2_id, int(w), prob)
            elif identifier == 'T':
                num = line.split(' ')[1]
                vertices_config['V' + num] = 1
                target = 'V' + num
            else:
                start = 'V' + line.split(' ')[1]
    return vertices_config, edges_config, start, target


"""##Algorithm"""


class MDP:
    def __init__(self, graph: Graph, target: str):
        self.graph = graph
        self.belief_states = OrderedDict({})
        self.tree_counter = 0
        self.target = target

        vertices = self.graph.get_vertices()
        E_prob = {e_id: 'U' if e.prob not in [0, 1] else e.prob for e_id, e in graph.get_edges().items()}
        for v_id in vertices:
            self.evaluation_tree = Tree()
            self.tree_counter = 1
            self.build_BS(v_id, E_prob, 0)
            self.evaluation_tree.show()

    def build_BS(self, v_id: str, E_prob: Dict[str, float], parent_id: int):
        uncertain_edges = [e_id for e_id, p in E_prob.items() if p not in [0, 1] and v_id in e_id]

        curr_id = v_id + ' ' + str(E_prob)
        for e_id, p in E_prob.items():
            e = self.graph.get_edges()[e_id]
            curr_vs_ids = e.get_vertices_ids()

            if p not in [0, 1, 'U'] and not len(uncertain_edges):
                self.add_bs(v_id, E_prob, parent_id)

            if p == 'U':
                p = e.prob
                curr_parent_id = self.tree_counter

                self.add_tree_node(parent_id, curr_id)

                self.tree_counter += 1

                for assignment in [0, 1, p]:
                    if assignment != p or v_id not in curr_vs_ids:
                        new_E_prob = E_prob.copy()
                        new_E_prob[e_id] = assignment
                        self.build_BS(v_id, new_E_prob, curr_parent_id)
                return

        self.add_tree_node(parent_id, curr_id)
        self.add_bs(v_id, E_prob, parent_id)
        self.tree_counter += 1

    def add_bs(self, v_id: str, E_prob: Dict[str, float], parent_id: int):
        new_E_prob = E_prob.copy()
        new_E_prob = {e_id: p if p != 'U' else self.graph.get_edges()[e_id].prob \
                      for e_id, p in new_E_prob.items()}
        curr_id = v_id + ' ' + str(new_E_prob)

        bs = BeliefState(v_id, new_E_prob, self.graph)
        self.belief_states[curr_id] = bs

    def add_tree_node(self, parent_id: int, curr_id: str):
        if parent_id == 0:
            self.evaluation_tree.create_node(tag=curr_id, identifier=1)
        else:
            self.evaluation_tree.create_node(tag=curr_id, identifier=self.tree_counter, parent=parent_id)

    def solve_bellman_equations(self, initial_value: float, epsilon: float):
        belief_states = self.belief_states
        for bs in belief_states.values():
            bs.utility_value = initial_value if bs.v_id != self.target else 0.0
        stop_cond = False

        j = 1
        plot_lst = []

        while not stop_cond:
            print(70 * '#' + str(j) + 70 * '#')
            U_t = {bs_id: bs.utility_value for bs_id, bs in belief_states.items() if bs.v_id != self.target}
            U_t_new = {bs_id: bs.bellman_equation(belief_states) for bs_id, bs in belief_states.items() if
                       bs.v_id != self.target}
            diff = {bs_id: abs(U_t[bs_id] - U_t_new[bs_id]) for bs_id in U_t.keys()}
            print(diff)
            for bs_id, bs in belief_states.items():
                if bs.v_id != self.target:
                    bs.utility_value = U_t_new[bs_id]

            norm = max(diff.values())
            plot_lst += [norm]
            stop_cond = norm < epsilon
            j += 1

        plt.plot(plot_lst)

        # print(np.array([bs.utility_value for bs in belief_states], dtype=np.float64))


class BeliefState:
    def __init__(self, L: str, E_prob: Dict[str, float], graph: Graph):
        self.v_id = L
        self.E_prob = E_prob
        self.graph = graph
        self.v = self.graph.get_vertices()[self.v_id]
        self.id = L + ' ' + str(self.E_prob)
        self.transition_prob: Dict[str, float] = self.create_T_prob()
        self.optimal_action = None
        self.utility_value = None

    @staticmethod
    def create_id(v_id, E_prob):
        return v_id + ' ' + str(E_prob)

    def create_T_prob(self):
        BS_prob = {}

        for e_id, e in self.v.edges.items():
            u = e.get_other_vertex(self.v)
            u_id = u.v_id
            if self.E_prob[e_id] != 1:
                found_prob_edge = False
                for k_id, k in u.edges.items():
                    k_vs = k.get_vertices_ids()

                    p = self.E_prob[k_id]
                    # if p not in [0,1] or self.v_id in k_vs:
                    if p not in [0.0, 1.0]:
                        found_prob_edge = True
                        for i in [0, 1]:
                            new_E_prob = self.E_prob.copy()
                            new_E_prob[k_id] = i
                            bs_id = BeliefState.create_id(u_id, new_E_prob)
                            BS_prob[bs_id] = p if i == 1 else 1 - p
                if not found_prob_edge:
                    new_E_prob = self.E_prob.copy()
                    bs_id = BeliefState.create_id(u_id, new_E_prob)
                    BS_prob[bs_id] = 1
            else:
                new_E_prob = self.E_prob.copy()
                bs_id = BeliefState.create_id(u_id, new_E_prob)
                BS_prob[bs_id] = 0
        return BS_prob

    def bellman_equation(self, belief_states: Dict):
        transition_prob = self.transition_prob
        # print('#'*10 + self.id + '#'*10)
        # print(transition_prob)
        actions_and_states = {}
        for s_id, p in transition_prob.items():
            if p > 0:
                s = belief_states[s_id]
                other = s.v_id
                w = self.graph.get_weight(self.v_id, s.v_id)
                element = s.utility_value * p
                # print(element)
                if other in actions_and_states:
                    actions_and_states[other] += element
                else:
                    actions_and_states[other] = element - w
        # print(actions_and_states)
        m = max(actions_and_states.values())
        k = max(actions_and_states, key=actions_and_states.get)
        self.optimal_action = k
        return m


class Simulation:
    def __init__(self, graph: Graph, start: str):
        self.graph = graph
        self.start = start

        E_prob = {e_id: e.prob for e_id, e in graph.get_edges().items()}
        BS_curr = BeliefState(start, E_prob, graph)


def run_simulation(config):
    vertices_config, edges_config, start, target = parse_config_string(config)
    graph = Graph.from_config(vertices_config, edges_config)
    graph.plot()
    mdp = MDP(graph, target)
    # print(mdp.belief_states.keys())
    mdp.solve_bellman_equations(-2, 0.01)
    for bs in mdp.belief_states.values():
        if bs.v_id != target:
            print(bs.id + ': ' + bs.optimal_action)


if __name__ == '__main__':
    run_simulation(config)
