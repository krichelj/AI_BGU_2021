# -*- coding: utf-8 -*-
"""HW_4_AI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1W-WBd72fL70bOgoqwX-ySbZBkw8GMiun
"""

from typing import Dict
from termcolor import colored
import random
import matplotlib.pyplot as plt
from collections import OrderedDict
from treelib import Tree

from Graph import Graph

"""#HW4

##Config
"""

config = '''
#V5    ; number of vertices n in graph (from 1 to n)

#E1 1 2 W3 ; Edge from vertex 1 to vertex 2, weight 3
#E2 2 3 W2 ; Edge from vertex 2 to vertex 3, weight 2
#E3 3 4 W1 B0.1 ; Edge from vertex 3 to vertex 4, weight 3, probability of blockage 0.3
#E4 4 5 W1 ; Edge from vertex 4 to vertex 5, weight 1
#E5 2 4 W4 ; Edge from vertex 2 to vertex 4, weight 4
#Start 1
#Target 5
'''

check = '''
#V6


#E1 1 2 W1
#E2 1 4 W1
#E3 2 3 W1 B0.9
#E4 4 5 W1 B0.8
#E5 5 6 W1
#E6 3 6 W1
#E7 1 6 W100

#Start 1
#Target 6
'''


def parse_config_string(config_string):
    vertices_config = {}
    edges_config = {}
    start = None
    target = None

    for line in config_string.split('\n'):
        if len(line) and line[0] == '#':
            identifier = line[1]

            if identifier == 'V':
                N = int(line[2:].split(' ')[0])
                for i in range(N):
                    vertices_config['V' + str(i + 1)] = 0
            elif identifier == 'E':
                b = None
                splitted = line[1:].replace('W', '').split(' ')[1:5]
                if len(splitted) == 3:
                    v1_num, v2_num, w = splitted
                else:
                    v1_num, v2_num, w, b = splitted

                v1v2 = sorted([v1_num, v2_num])
                v1_id = 'V' + v1v2[0]
                v2_id = 'V' + v1v2[1]
                prob = 0 if not b or not len(b) or b[0] != 'B' else float(b[1:])
                edges_config[v1_id + v2_id] = (v1_id, v2_id, int(w), prob)
            elif identifier == 'T':
                num = line.split(' ')[1]
                vertices_config['V' + num] = 1
                target = 'V' + num
            else:
                start = 'V' + line.split(' ')[1]
    return vertices_config, edges_config, start, target


class MarkovDecisionProblem:
    def __init__(self, graph: Graph, target: str):
        self.graph = graph
        self.belief_states = OrderedDict({})
        self.tree_counter = 0
        self.target = target

        vertices = self.graph.get_vertices()
        E_prob = {e_id: 'U' if e.prob not in [0, 1] else e.prob for e_id, e in graph.get_edges().items()}
        for v_id in vertices:
            self.evaluation_tree = Tree()
            self.tree_counter = 1
            self.build_bs(v_id, E_prob, 0)
            # self.evaluation_tree.show()

    def build_bs(self, v_id: str, E_prob: Dict[str, float], parent_id: int):
        uncertain_edges = [e_id for e_id, p in E_prob.items() if p not in [0, 1] and v_id in e_id]

        curr_id = v_id + ' ' + str(E_prob)
        for e_id, p in E_prob.items():
            e = self.graph.get_edges()[e_id]
            curr_vs_ids = e.get_vertices_ids()

            if p not in [0, 1, 'U'] and not len(uncertain_edges):
                self.add_bs(v_id, E_prob)

            if p == 'U':
                p = e.prob
                curr_parent_id = self.tree_counter

                self.add_tree_node(parent_id, curr_id)

                self.tree_counter += 1

                for assignment in [0, 1, p]:
                    if assignment != p or v_id not in curr_vs_ids:
                        new_E_prob = E_prob.copy()
                        new_E_prob[e_id] = assignment
                        self.build_bs(v_id, new_E_prob, curr_parent_id)
                return

        self.add_tree_node(parent_id, curr_id)
        self.add_bs(v_id, E_prob)
        self.tree_counter += 1

    def add_bs(self, v_id: str, E_prob: Dict[str, float]):
        new_E_prob = E_prob.copy()
        new_E_prob = {e_id: p if p != 'U' else self.graph.get_edges()[e_id].prob
                      for e_id, p in new_E_prob.items()}
        curr_id = v_id + ' ' + str(new_E_prob)

        bs = BeliefState(v_id, new_E_prob, self.graph)
        self.belief_states[curr_id] = bs

    def add_tree_node(self, parent_id: int, curr_id: str):
        if parent_id == 0:
            self.evaluation_tree.create_node(tag=curr_id, identifier=1)
        else:
            self.evaluation_tree.create_node(tag=curr_id, identifier=self.tree_counter, parent=parent_id)

    def solve_Bellman_equations(self, initial_optimal_values: float, epsilon: float, start: str, target: str):
        for bs in self.belief_states.values():
            bs.utility_value = initial_optimal_values if bs.v_id != self.target else 0.0
        stop_cond = False

        j = 1
        plot_lst = []

        while not stop_cond:
            # print(70 * '#' + str(j) + 70 * '#')
            U_t = {bs_id: bs.utility_value for bs_id, bs in self.belief_states.items() if bs.v_id != self.target}
            U_t_new = {bs_id: bs.Bellman_equation(self.belief_states, start, target, initial_optimal_values)
                       for bs_id, bs in self.belief_states.items() if bs.v_id != self.target}
            diff = {bs_id: abs(U_t[bs_id] - U_t_new[bs_id]) for bs_id in U_t.keys()}
            # print(diff)

            norm = max(diff.values())
            plot_lst += [norm]
            stop_cond = norm < epsilon
            j += 1

            if not stop_cond:
                for bs_id, bs in self.belief_states.items():
                    if bs.v_id != self.target:
                        bs.utility_value = U_t_new[bs_id]

        plt.plot(plot_lst, '-o')
        plt.hlines(y=epsilon, xmin=0, xmax=len(plot_lst), colors='red')
        plt.legend(['$||U_{t}-U_{t-1}||$', '$\\varepsilon$'], fontsize=16)
        plt.xlabel('$t$', fontsize=16)
        plt.grid()
        plt.show()


class BeliefState:
    def __init__(self, L: str, E_prob: Dict[str, float], graph: Graph):
        self.v_id = L
        self.E_prob = E_prob
        self.graph = graph
        self.v = self.graph.get_vertices()[self.v_id]
        self.id = L + ' ' + str(self.E_prob)
        self.transition_prob: Dict[str, float] = {}
        self.optimal_action = None
        self.utility_value = None
        self.create_T_prob()

    @staticmethod
    def create_id(v_id, E_prob):
        return v_id + ' ' + str(E_prob)

    def create_T_prob(self):
        for e_id, e in self.v.edges.items():
            u = e.get_other_vertex(self.v)
            u_id = u.v_id

            if self.E_prob[e_id] != 1:
                found_prob_edge = False

                for k_id, k in u.edges.items():
                    p = self.E_prob[k_id]

                    if 0 < p < 1:
                        found_prob_edge = True
                        for i in [0, 1]:
                            new_E_prob = self.E_prob.copy()
                            new_E_prob[k_id] = i
                            bs_id = BeliefState.create_id(u_id, new_E_prob)
                            self.transition_prob[bs_id] = p if i == 1 else 1 - p

                if not found_prob_edge:
                    self.create_bs(u_id, 1)
            else:
                self.create_bs(u_id, 0)

    def create_bs(self, u_id, p):
        new_E_prob = self.E_prob.copy()
        bs_id = BeliefState.create_id(u_id, new_E_prob)
        self.transition_prob[bs_id] = p

    def Bellman_equation(self, belief_states: Dict, start: str, target: str, initial_optimal_values: float):
        transition_prob = self.transition_prob
        # print('#'*10 + self.id + '#'*10)
        actions_and_states: Dict[str, float] = {}

        for bs_id, p in transition_prob.items():
            if bs_id in belief_states and p > 0:
                bs = belief_states[bs_id]
                other = bs.v_id
                w = self.graph.get_weight(self.v_id, other)
                element = bs.utility_value * p
                # print(element)
                if other in actions_and_states:
                    actions_and_states[other] += element
                else:
                    actions_and_states[other] = element - w

        if self.id == "V1 {'V1V2': 0, 'V1V4': 0, 'V2V3': 1, 'V4V5': 0.8, 'V5V6': 0, 'V3V6': 0, 'V1V6': 1}":
            print(actions_and_states)

        blocked = False
        if all([any([self.E_prob[e] == 1 for e in path]) for path in self.graph.get_all_paths(start, target)]):
            blocked = True

        m = max(actions_and_states.values()) if len(actions_and_states) and not blocked else - initial_optimal_values
        self.optimal_action = max(actions_and_states, key=actions_and_states.get) \
            if len(actions_and_states) and not blocked else None

        return m


class Simulation:
    def __init__(self, config: str):
        vertices_config, edges_config, self.start, self.target = parse_config_string(config)
        self.graph = Graph.from_config(vertices_config, edges_config)
        self.mdp = MarkovDecisionProblem(self.graph, self.target)

        start_E_prob = {e_id: e.prob if self.start not in e_id else (1 if random.random() < e.prob else 0)
                        for e_id, e in self.graph.get_edges().items()}
        start_id = BeliefState.create_id(self.start, start_E_prob)
        self.initial_utility_value = - sum([e.w for e in self.graph.get_edges().values()])
        self.curr_bs = self.mdp.belief_states[start_id]
        self.bss = [self.curr_bs.id]
        self.cost = 0
        self.path = [self.start]
        self.next_vertex = None

    def run_simulation(self, epsilon: float, edges_assignment: Dict[str, int] = None):
        self.graph.plot()
        self.mdp.solve_Bellman_equations(self.initial_utility_value, epsilon, self.start, self.target)
        print(colored('Belief states and optimal actions:', 'green'))
        printed = []
        for bs in self.mdp.belief_states.values():
            if bs.v_id != self.target:
                if bs.v_id not in printed:
                    printed += [bs.v_id]
                    print('#' * 50 + bs.v_id + '#' * 50)
                print(bs.id + ': U = ' + str(bs.utility_value) +
                      ', optimal action = ' + bs.v_id + '->' + (bs.optimal_action if bs.optimal_action else 'None'))

        self.next_vertex = self.curr_bs.optimal_action
        if self.next_vertex:
            self.path += [self.next_vertex]

        stuck = False
        edges_assignment_keys = edges_assignment.keys()

        while self.next_vertex != self.target and not stuck:
            assigned_edges = [e_id for e_id in edges_assignment_keys if self.next_vertex in e_id]
            curr_transition = {bs_id: p for bs_id, p in self.curr_bs.transition_prob.items()
                               if p > 0 and self.mdp.belief_states[bs_id].v_id == self.next_vertex}
            if len(assigned_edges):
                curr_transition = {bs_id: p for bs_id, p in self.curr_bs.transition_prob.items()
                                   if p > 0 and self.mdp.belief_states[bs_id].v_id == self.next_vertex
                                   and self.mdp.belief_states[bs_id].E_prob[assigned_edges[0]] == edges_assignment[
                                       assigned_edges[0]]}

            curr_transitions_keys = list(curr_transition.keys())
            number_of_possible_transitions = len(curr_transition)

            if number_of_possible_transitions:
                # if number_of_possible_transitions == 1:
                #     key = 0
                # else:
                #     draw = random.random()
                #     key = 0 if curr_transitions[curr_transitions_keys[0]] > draw else 1

                self.cost += self.graph.get_weight(self.curr_bs.v_id, self.curr_bs.optimal_action)
                self.curr_bs = self.mdp.belief_states[curr_transitions_keys[0]]
                self.bss += [self.curr_bs.id]
                self.next_vertex = self.curr_bs.optimal_action
                if self.next_vertex:
                    self.path += [self.next_vertex]
                else:
                    stuck = True
            else:
                stuck = True

        self.cost += self.graph.get_weight(self.curr_bs.v_id, self.curr_bs.optimal_action) \
            if self.curr_bs.optimal_action else 0

        if stuck:
            print(colored('\nThe traversal was stuck in the middle!', 'red'))

        print(colored('\nFinal path: ' + str(self.path) + ', Total time: ' + str(self.cost), 'red'))
        print(colored('\nActual states:\n' + '\n'.join(self.bss), 'red'))


if __name__ == '__main__':
    epsilon = 0.1
    edges_assignment = {'V2V3': 1, 'V4V5': 1}
    sim = Simulation(check)
    sim.run_simulation(epsilon, edges_assignment)
